---
description: Core SDA architectural principles
globs:
alwaysApply: true
---

# Semantic Domain Architecture Core

## Fundamental Principle
Data drives behavior. Business logic lives with the data it operates on.
**Type transitions must be CONSTRUCTIVE transformations, not ASSERTIVE declarations.**

## Constructive Type Proofs (The Heart of SDA)

### Core Law
Every type boundary crossing requires visible proof through explicit construction, not invisible claims through casting or ignoring.

### BANNED - Assertive Type Coercion
- **cast()** - BANNED. Construct the type explicitly.
- **type: ignore** - BANNED except as truly last resort with justification.
- **Suppressing type errors** - BANNED. Fix through construction.

### REQUIRED - Constructive Type Transformation
- **Unpack components explicitly** - Extract each field with its type
- **Transform individually** - Convert each piece to domain type
- **Reconstruct target type** - Build from typed components
- **Construction IS proof** - Success proves type safety

### The Unpacking Pattern
1. Destructure source into typed components
2. Transform each component to domain type
3. Construct target from typed parts
4. Construction failure = immediate error (good!)

## Architecture Pattern
- **Models**: Domain intelligence (BaseModel with business logic)
- **Services**: Infrastructure orchestration only (no business decisions)
- **Protocols**: External dependency contracts

## Separation of Concerns
**Models decide, Services orchestrate:**
- Models: Discriminated union business logic methods
- Services: Infrastructure orchestration only
- Never: Services making business decisions about models

## Type Dispatch Framework
- Primitive with domain meaning → Value Object (BaseModel)
- Finite choices with behavior → StrEnum with methods (never string literals)  
- Derived from other fields → @computed_field
- External dependency → Protocol
- Infrastructure coordination → Service

## Immutability
- All models frozen by default: `model_config = {"frozen": True}`
- State changes via `model_copy(update={"field": new_value})`
- No direct mutation of model fields
