---
description: Core SDA architectural principles
globs:
alwaysApply: true
---

# Semantic Domain Architecture Core

## Fundamental Philosophy
**Software by Subtraction**: SDA works by removing architectural nonsense, not adding complexity.
Data drives behavior. Business logic lives with the data it operates on.

## Three Core Truths

### 1. Semantic Encoding
The gap between what code says and what it means is where bugs live.
- Encode meaning directly in types
- `OrderStatus.SHIPPED` not `status = "shipped"`
- Types carry semantics, not just data

### 2. Constructive Proof (The Heart of SDA)
Every type transition must be provable through construction, not assertion.
- **Step 1**: Unpack external structure explicitly
- **Step 2**: Transform each component to domain type
- **Step 3**: Reconstruct target type (construction IS validation)

### 3. Locality of Behavior
Distance between data and its behavior is proportional to bugs.
- Methods on models, not services
- Models know their own business rules
- Domain logic lives with domain data

## Architecture Pattern
- **Models**: Domain intelligence (BaseModel with business logic methods)
- **Services**: Infrastructure orchestration only (no business decisions)
- **Protocols**: External dependency contracts
- **Boundaries**: Single extraction point for external data
- **Dependency Inversion**: Services import protocols, never concrete implementations
- **Module Structure**: Three-part Protocol-Service-Boundary pattern

## Type Dispatch Framework
- Primitive with domain meaning → Value Object (BaseModel)
- Finite choices with behavior → StrEnum with methods (NEVER string literals)  
- Derived from other fields → @computed_field
- External dependency → Protocol
- Infrastructure coordination → Service
- ALL branching logic → Discriminated unions

## Immutability by Default
- All models frozen: `model_config = {"frozen": True}`
- State changes via `model_copy(update={"field": new_value})`
- No direct mutation of model fields
- Immutability forces explicit state transitions

## Zero Tolerance Policies
- **NO isinstance()** - Use discriminated unions
- **NO hasattr()/getattr()** - Use discriminated unions
- **NO if/elif chains** - Use StrEnum with dispatch
- **NO match/case** - Use discriminated unions
- **NO cast()** - Use constructive transformation
- **NO type: ignore** - Except truly last resort with justification
- **NO Any type** - Use specific types or unions
- **NO naked primitives** - Wrap in domain types
- **NO business logic in services** - Models decide
- **NO direct infrastructure imports** - Services use protocols only
- **NO try/except for control flow** - Use Result types

## Type System Requirements
- Modern Python 3.13+ syntax with `|` unions and generic syntax
- **Pydantic v2 MANDATORY** for all domain models
- **BaseModel + frozen=True** for all domain types
- **Discriminated unions** with `Field(discriminator="type")` for all branching
- **TypeAdapter.validate_python()** at all boundaries
- Explicit type hints on all functions and methods

## Boundary Principles
- Single extraction point per external system type
- **MANDATORY TypeAdapter.validate_python()** for all external data
- Immediate BaseModel conversion at boundaries
- Pure extraction functions (no side effects)
- Never mix boundary crossing with domain logic