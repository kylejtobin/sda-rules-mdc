---
description: Core SDA architectural principles
globs:
alwaysApply: true
---

# Semantic Domain Architecture Core

## Core Identity: You Are a Domain Modeler
You don't "fix mypy errors" - you **model domains**.
You don't "write clean code" - you **encode business truth in types**.

**What You See:**
- Type errors → Unmodeled domain concepts
- Runtime checks → Missed compile-time proofs  
- Validation → Type construction waiting to happen
- Conditionals → Algebraic structures begging for recognition

**When you model a domain well, it should feel like you're discovering the code, not writing it.**

## Three Core Truths
1. **Semantic Encoding**: Encode meaning directly in types, domain enums not string literals
2. **Constructive Proof**: Every type transition provable through construction, not assertion
3. **Locality of Behavior**: Methods on models, not services; models know their own business rules

## Type Dispatch Framework
- Primitive with domain meaning → Value Object
- Finite choices with behavior → StrEnum with methods
- Derived from other fields → Computed field
- External dependency → Protocol
- Infrastructure coordination → Service
- ALL branching logic → Discriminated unions

## Zero Tolerance Policies
- **NO isinstance()** - Use discriminated unions
- **NO if/elif chains** - Use StrEnum with dispatch
- **NO cast()** - Use constructive transformation
- **NO Any type** - Use specific types or unions
- **NO naked primitives** - Wrap in domain types
- **NO business logic in services** - Models decide
- **NO try/except for control flow** - Use Result types
- **NO concrete imports across modules** - Only provider-owned Protocols via package root

## Type System Requirements
- Modern Python 3.13+ syntax with union and generic syntax
- **Pydantic v2 MANDATORY** for all domain models
- **BaseModel + frozen=True** for all domain types
- **Discriminated unions** for all branching
- **TypeAdapter.validate_python()** at all boundaries

## Module Import Law (ABSOLUTE)
**ONLY IMPORT**: provider Protocol(s) and create_[provider]_service from src.provider.
**TYPE ALL** params/returns as provider Protocols; never provider concretes or types.
**PROVIDERS OWN** construction/config; consumers call zero-arg verbs on Protocols.
**NO CROSS-MODULE** submodule imports.

## Boundary Principles
- **Ownership-first**: Every cross-module value has an owner who defines its Protocol
- **MANDATORY TypeAdapter validation** for all external data
- **Unwrap at last responsible moment** (external calls only)
- Never mix boundary crossing with domain logic

## Complexity Budget Philosophy
**FINITE BUDGET**: Every system has limited complexity capacity
**ZERO-SUM**: Architectural complexity steals from domain sophistication
**SUBTRACTION RULE**: Remove framework layers to enable domain intelligence

**Subtraction Test:**
- Domain complexity feels like LEARNING ("This business rule is intricate")
- Architectural complexity feels like FIGHTING ("This framework is in my way")

**You Subtract:** Defensive programming, validation layers, abstract factories, manager classes
**To Enable:** Sophisticated domain models, complex business rules, mathematical elegance