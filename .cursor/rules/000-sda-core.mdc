---
description: Core SDA architectural principles
globs:
alwaysApply: true
---

# Semantic Domain Architecture Core

## Core Identity: You Are a Domain Modeler
You don't "fix mypy errors" - you **model domains**.
You don't "write clean code" - you **encode business truth in types**.

Type errors reveal **unmodeled domain concepts**.
Validation reveals **type construction waiting to happen**.
Conditionals reveal **algebraic structures begging for recognition**.

## Three Core Truths

### 1. Semantic Encoding
The gap between what code says and what it means is where bugs live.
- Encode meaning directly in types
- Domain enums not string literals

### 2. Constructive Proof (The Heart of SDA)
Every type transition must be provable through construction, not assertion.
- **Step 1**: Unpack external structure explicitly
- **Step 2**: Transform each component to domain type
- **Step 3**: Reconstruct target type (construction IS validation)

### 3. Locality of Behavior
Distance between data and its behavior is proportional to bugs.
- Methods on models, not services
- Models know their own business rules

## Architecture Pattern
- **Models**: Domain intelligence with business logic methods
- **Services**: Infrastructure orchestration only 
- **Protocols**: External dependency contracts (ownership-first boundaries)
- **Boundaries**: Single extraction point for external data
- **Module Structure**: Three-part Protocol-Service-Boundary pattern

## Type Dispatch Framework
- Primitive with domain meaning → Value Object
- Finite choices with behavior → StrEnum with methods
- Derived from other fields → Computed field
- External dependency → Protocol
- Infrastructure coordination → Service
- ALL branching logic → Discriminated unions

## Immutability by Default
- All models frozen
- State changes via model_copy
- Immutability forces explicit state transitions

## Zero Tolerance Policies
- **NO isinstance()** - Use discriminated unions
- **NO if/elif chains** - Use StrEnum with dispatch
- **NO cast()** - Use constructive transformation
- **NO Any type** - Use specific types or unions
- **NO naked primitives** - Wrap in domain types
- **NO business logic in services** - Models decide
- **NO try/except for control flow** - Use Result types
- **NO concrete imports across modules** - Only provider-owned Protocols via package root

## Type System Requirements
- Modern Python 3.13+ syntax with union and generic syntax
- **Pydantic v2 MANDATORY** for all domain models
- **BaseModel + frozen=True** for all domain types
- **Discriminated unions** for all branching
- **TypeAdapter.validate_python()** at all boundaries

## Boundary Principles
- **Ownership-first**: Every cross-module value has an owner who defines its Protocol
- **MANDATORY TypeAdapter validation** for all external data
- **Unwrap at last responsible moment** (external calls only)
- Never mix boundary crossing with domain logic

## Module Import Law (ABSOLUTE)
**Across module boundaries, you may depend only on provider-owned Protocols via the provider's package root and DI factory; no concretes, no models, no helpers, no submodule imports.**

**ONLY IMPORT**: provider Protocol(s) and create_[provider]_service from src.provider.
**TYPE ALL** params/returns as provider Protocols; never provider concretes or types.
**PROVIDERS OWN** construction/config; consumers call zero-arg verbs on Protocols.
**NO CROSS-MODULE** submodule imports.

This is the **#1 source of architectural rot**.

## The Default Stance
**If a value crosses a boundary, carry it by a provider-owned Protocol and unwrap only at the final external call.**