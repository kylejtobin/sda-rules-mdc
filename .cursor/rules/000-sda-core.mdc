---
description: Core SDA architectural principles
globs:
alwaysApply: true
---

# Semantic Domain Architecture Core

## Fundamental Philosophy
**Software by Subtraction**: SDA works by removing architectural nonsense, not adding complexity.
Data drives behavior. Business logic lives with the data it operates on.

## Three Core Truths

### 1. Semantic Encoding
The gap between what code says and what it means is where bugs live.
- Encode meaning directly in types
- `OrderStatus.SHIPPED` not `status = "shipped"`
- Types carry semantics, not just data

### 2. Constructive Proof (The Heart of SDA)
Every type transition must be provable through construction, not assertion.
- **Unpack components explicitly** - Extract each field with its type
- **Transform individually** - Convert each piece to domain type
- **Reconstruct target type** - Build from typed components
- **Construction IS validation** - Success proves type safety

```python
# ✅ Constructive transformation
def to_domain(raw: dict) -> DomainModel:
    # Unpack
    id_raw = raw.get("id")
    value_raw = raw.get("value")
    # Transform
    domain_id = DomainId(id_raw) if id_raw else DomainId.anonymous()
    domain_value = Value.from_raw(value_raw)
    # Reconstruct (construction IS validation)
    return DomainModel(id=domain_id, value=domain_value)
```

### 3. Locality of Behavior
Distance between data and its behavior is proportional to bugs.
- Methods on models, not services
- Models know their own business rules
- Domain logic lives with domain data

## Architecture Pattern
- **Models**: Domain intelligence (BaseModel with business logic methods)
- **Services**: Infrastructure orchestration only (no business decisions)
- **Protocols**: External dependency contracts
- **Boundaries**: Single extraction point for external data
- **Dependency Inversion**: Services import protocols, never concrete implementations

## Type Dispatch Framework
- Primitive with domain meaning → Value Object (BaseModel)
- Finite choices with behavior → StrEnum with methods (NEVER string literals)  
- Derived from other fields → @computed_field
- External dependency → Protocol
- Infrastructure coordination → Service
- ALL branching logic → Discriminated unions

## Immutability by Default
- All models frozen: `model_config = {"frozen": True}`
- State changes via `model_copy(update={"field": new_value})`
- No direct mutation of model fields
- Immutability forces explicit state transitions

## Zero Tolerance Policies
- **NO isinstance()** - Use discriminated unions
- **NO hasattr()/getattr()** - Use discriminated unions
- **NO if/elif chains** - Use StrEnum with dispatch
- **NO cast()** - Use constructive transformation
- **NO type: ignore** - Except truly last resort with justification
- **NO naked primitives** - Wrap in domain types
- **NO business logic in services** - Models decide
- **NO direct infrastructure imports** - Services use protocols only

## Boundary Principles
- Single extraction point per external system type
- Immediate domain conversion at boundaries
- Pure extraction functions (no side effects)
- TypeAdapter for validation at system edges
- Never mix boundary crossing with domain logic