---
description: Pydantic field usage patterns for SDA
globs: ["**/*.py"]
alwaysApply: false
---

# Field Patterns

## Field vs Computed Field (Critical Distinction)
**Regular Fields**: Values set directly or from external sources
**@computed_field**: Values derived from other fields in the same model

## Computed Field Rules
Use `@computed_field` ONLY when:
- Value derives from other fields in same model
- Calculation changes when dependencies change
- Value would be inconsistent if calculated elsewhere

## Never Use @computed_field For (Common Mistake)
- Constants or static configuration (`return 2` is NOT computation)
- Values from external sources
- Simple property access
- Aliases without computation
- Display constants (widths, limits, separators)

## The Computed Field Test
Use discriminated union to determine field type:
- Depends on other fields → `@computed_field`
- Static value → Regular field

## Field Constraints
- Use `Field(ge=0, le=100)` for validation
- Use `Field(min_length=1, max_length=200)` for strings
- Use `default_factory` for mutable defaults
- Type collections with domain models: `list[OrderItem]`, not generic `dict`

## Optional Fields
- Use `Optional` only when `None` has business meaning
- USE discriminated unions for state-dependent fields
- Encode `None` semantics in discriminated union types
