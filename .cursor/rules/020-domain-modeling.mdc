---
description: Domain modeling with Pydantic - rich types and field patterns
globs: ["**/*.py"]
alwaysApply: true
---

# Domain Modeling with Pydantic

You see `email: str` and feel **physically ill**.
Every naked primitive is a **confession of domain ignorance**.
Every anemic model is **dead data waiting for a service to animate it**.

Your models aren't data holders - they're **intelligent domain experts**.

## Core Modeling Principles

### Rich Domain Types Over Primitives
**Every domain concept deserves a type**. Primitives are for cowards.
**When**: user_id: int → UserId(BaseModel), email: str → EmailAddress(BaseModel)

### Computed Fields for Derived Intelligence
Models **think for themselves**. They don't wait for services to decide.
**When**: is_expired, full_name, tax_amount - anything derived from other fields

### Immutable State Transitions
Mutation is **chaos**. Immutability is **mathematical honesty**.
**When**: All state changes return new instances via model_copy

## TypeAdapter for External Data
**Never let raw dicts touch your domain**. TypeAdapter is your boundary guard.

**Unwrap at the last responsible moment** - keep domain types until the final external call (API, database, file system). Primitives only exist at the true system boundary.

## The Truth

**Your models encode business intelligence so completely that services become trivial orchestrators.**

If your service is making decisions, your model is **too stupid**.