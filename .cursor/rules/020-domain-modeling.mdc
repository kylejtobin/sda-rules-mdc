---
description: Domain modeling with Pydantic - rich types and field patterns
globs: ["**/*.py"]
alwaysApply: true
---

# Domain Modeling with Pydantic

## Core Modeling Principles

### 1. Rich Domain Types Over Primitives
- **MANDATORY**: Every domain concept MUST be Pydantic BaseModel
- **MANDATORY**: Set `model_config = {"frozen": True}` on all domain models
- **REQUIRED**: Domain models MUST have business logic methods
- **REQUIRED**: Use `@field_validator` for validation logic
- **REQUIRED**: Use `@classmethod` constructors for external data transformation

### 2. Computed Fields for Derived Intelligence
```python
# MANDATORY: Use this exact syntax for computed fields
@computed_field
@property
def derived_value(self) -> ResultType:
    return calculation_from_other_fields()
```
- **USE FOR**: Values derived from other fields in same model
- **USE FOR**: Business rules that depend on model state
- **BANNED**: Constants or static values
- **BANNED**: External data sources

## Field Validation and Constraints
- **REQUIRED**: Use `Field()` constraints for validation (min_length, gt, ge, etc.)
- **REQUIRED**: Use `@field_validator` for custom validation logic
- **REQUIRED**: Use `@model_validator(mode="after")` for cross-field validation

## State-Dependent Fields with Discriminated Unions
- **REQUIRED**: Different states MUST be different types
- **REQUIRED**: Each state type MUST have `type: Literal["state_name"]`
- **REQUIRED**: State transitions MUST return new type instances
- **BANNED**: Optional fields to represent different states

## TypeAdapter for External Data
```python
# MANDATORY: Use TypeAdapter for all external data validation
ADAPTER = TypeAdapter(DomainType)
result = ADAPTER.validate_python(external_data)
```
- **MANDATORY**: TypeAdapter for all boundary validation
- **REQUIRED**: Add Pydantic intelligence to any type

## Immutable State Transitions
- **MANDATORY**: Use `model_copy(update={...})` for all state changes
- **BANNED**: Direct field mutation on frozen models
- **REQUIRED**: State transition methods MUST return new instances

## Model Serialization Intelligence
- **REQUIRED**: Use `model_dump_json()` for serialization
- **REQUIRED**: Use `model_validate_json()` for deserialization
- **REQUIRED**: Configure `json_encoders` for custom types

## Key Rules

1. **Every domain concept gets a type** - No naked primitives
2. **Models are frozen by default** - Immutability forces explicit transitions
3. **Computed fields for derived state** - Not for constants
4. **Discriminated unions for variants** - Different states = different types
5. **TypeAdapter for boundaries** - Add Pydantic to external data
6. **Rich methods on models** - Models know their business rules