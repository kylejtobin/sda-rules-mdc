---
description: Patterns for handling external system boundaries
globs: ["**/*.py"]
alwaysApply: false
---

# Boundary Intelligence Patterns

## Core Principle
Don't fight external systems—extract domain intelligence from them.

## Boundary Recognition
- **External systems**: AST nodes, HTTP requests, database rows, file formats
- **Domain models**: Your semantic understanding of external data
- **Extraction layer**: Pure functions that cross boundaries once
- **TypeAdapter**: Pydantic's tool for boundary validation

## Banned Boundary Patterns
- **Leaky abstractions** - Domain models wrapping external objects
- **Mixed logic** - Boundary crossing + domain logic in same function
- **Stateful extraction** - Services accumulating state during boundary crossing
- **Nested external dispatch** - Multiple levels of external type checking

## Required Boundary Patterns
- **Single extraction point** - One place per external system type
- **Immediate domain conversion** - External data becomes domain models quickly
- **Pure extraction functions** - Boundary crossing with no side effects
- **Explicit boundary classes** - Clear separation of boundary vs domain logic

## Boundary Design Rules
- External type checking only in extraction functions
- Domain models never import external system modules
- TypeAdapter for validation at system boundaries
- Functional visitors that produce domain models, not side effects
- Metadata extraction instead of direct external object wrapping

## Type System Boundary Principle
When discriminated unions provide stronger guarantees than static type checkers can verify:
- **Keep domain models strongly typed** - Never weaken types to satisfy MyPy
- **Prefer constructive transformation** - Unpack and explicitly type instead of type ignore
- **Type ignore is LAST RESORT** - Only when construction is truly impossible
- **Document the domain intelligence** - If you must use type ignore, explain the guarantee
- **Trust discriminated unions over type checkers** - Domain models encode more intelligence than MyPy can verify

## Constructive Transformation at Boundaries (PREFERRED)
```python
# ✅ BEST: Unpack and explicitly construct
if type(node) is ast.If:
    # Extract components with explicit types
    test_expr: ast.expr = node.test
    body: list[ast.stmt] = node.body
    
    # Construct domain model from typed components
    return ConditionalDomain(
        condition=extract_condition(test_expr),
        then_branch=extract_branch(body)
    )

# ⚠️ LAST RESORT: Type ignore only when construction impossible
# (e.g., when framework requires specific signature)
dispatch[node_type](node)  # type: ignore[arg-type] - Discriminated union guarantees ast.If
```