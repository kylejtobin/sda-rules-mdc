---
description: SDA transformation patterns and examples
globs:
alwaysApply: false
---

# SDA Reference Patterns

## Conditional → Type Dispatch
```python
# ❌ Before: Procedural conditional chains
violation_processor = get_violation_processor(violation_type)

# ✅ After: Type dispatch with enum behavior
class ViolationType(StrEnum):
    isinstance_violations = "isinstance_violations"
    hasattr_violations = "hasattr_violations"

    def create_finding(self, node: CodeNode) -> Finding:
        # Enum knows how to create its own findings
        return Finding(type=self, node=node)
```

## Runtime Checking → Discriminated Unions
```python
# ❌ Before: Runtime type checking with procedural logic
order_processor = get_order_processor(order.status)

# ✅ After: Discriminated union with type dispatch
class OrderStatus(StrEnum):
    PAID = "paid"
    DRAFT = "draft"
    
    def process(self, order: "Order") -> ProcessResult:
        # Type-safe dispatch without generics
        return {
            OrderStatus.PAID: order.ship,
            OrderStatus.DRAFT: order.reject_shipping
        }[self](order)
```

## Primitive → Value Object
```python
# ❌ Before: Primitive obsession
file_path: str = "src/models.py"
# Conditional logic with primitives

# ✅ After: Value object with domain intelligence
class FilePath(BaseModel):
    path: str

    @computed_field
    @property
    def file_type(self) -> FileType:
        # Push string operations to type system
        return FileType.from_path(self.path)

    @computed_field
    @property
    def module_name(self) -> ModuleName:
        # Domain intelligence in value objects
        return ModuleName.from_path(self.path)
```

## State → Discriminated Union Pattern
```python
# ❌ Before: Procedural state logic
state_processor = get_state_processor(current_state)

# ✅ After: Discriminated union state dispatch
class ProcessingState(StrEnum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    
    def get_result(self, value: ProcessValue, default: ProcessValue) -> ProcessValue:
        # Pure type dispatch without lambdas
        return {
            ProcessingState.ACTIVE: value,
            ProcessingState.INACTIVE: default
        }[self]
```

## External System → Domain Intelligence
```python
# ❌ Before: Fighting external polymorphism with conditionals
if isinstance(node, ast.If):
    return ConditionalViolation(node)
elif isinstance(node, ast.For):
    return LoopViolation(node)
# Nested conditionals throughout analysis

# ✅ After: Single boundary extraction + pure domain logic
def extract_analysis_domain(node: ast.AST) -> AnalysisDomain | None:
    """Pure boundary crossing: AST → Domain meaning."""
    metadata = extract_ast_metadata(node)
    
    # Single place for external type dispatch
    extractors = {
        ast.If: lambda n: ConditionalDomain.from_ast(n, metadata),
        ast.For: lambda n: LoopDomain.from_ast(n, metadata),
        ast.FunctionDef: lambda n: FunctionDomain.from_ast(n, metadata)
    }
    
    extractor = extractors.get(type(node))
    return extractor(node) if extractor else None

class ConditionalDomain(BaseModel):
    """Domain intelligence extracted from external AST."""
    test_expression: str
    metadata: ASTNodeMetadata
    
    @classmethod
    def from_ast(cls, node: ast.If, metadata: ASTNodeMetadata) -> 'ConditionalDomain':
        # Boundary method: Extract semantics once
        return cls(
            test_expression=extract_test_semantics(node.test),
            metadata=metadata
        )
    
    @computed_field
    @property
    def violation_type(self) -> ViolationType:
        # Pure domain logic with no external dependencies
        return self.metadata.category.get_violation_type()
```

## Boundary Services → Pure Functions
```python
# ❌ Before: Service classes with stateful boundary handling
class ASTAnalyzer:
    def __init__(self):
        self.violations = []  # Stateful accumulation
    
    def analyze_file(self, path):
        # Mixed boundary + domain logic
        tree = ast.parse(path.read_text())
        self._visit_node(tree)  # Stateful recursion
        return self.violations

# ✅ After: Pure functional boundary crossing
def analyze_ast_file(file_path: Path) -> list[Finding]:
    """Pure function: File → Domain findings."""
    tree = ast.parse(file_path.read_text())  # Boundary operation
    return analyze_ast_tree(tree)  # Pure domain logic

def analyze_ast_tree(tree: ast.AST) -> list[Finding]:
    """Pure function: External structure → Domain findings."""
    domains = extract_all_domains(tree)
    return [domain.analyze() for domain in domains if domain]

class DomainExtractor:
    """Functional visitor that produces domain models."""
    
    def visit(self, node: ast.AST) -> list[AnalysisDomain]:
        current = extract_analysis_domain(node)  # Boundary crossing
        children = [
            child_domain 
            for child in ast.iter_child_nodes(node)
            for child_domain in self.visit(child)
        ]
        return ([current] if current else []) + children
```

## TypeAdapter for Boundary Validation
```python
# ❌ Before: Manual validation at boundaries
def process_request(raw_data: dict):
    if 'user_id' not in raw_data:
        raise ValueError("Missing user_id")
    if not isinstance(raw_data['amount'], (int, float)):
        raise ValueError("Invalid amount")
    # Manual validation hell

# ✅ After: TypeAdapter for boundary safety
from pydantic import TypeAdapter

# Boundary validation adapters
HTTP_REQUEST_ADAPTER = TypeAdapter(HttpRequestData)
AST_NODE_ADAPTER = TypeAdapter(ast.AST)

def process_request(raw_data: dict) -> ProcessResult:
    """Safe boundary crossing with validation."""
    validated_request = HTTP_REQUEST_ADAPTER.validate_python(raw_data)
    domain_command = extract_command_from_request(validated_request)
    return domain_command.execute()

class ASTBoundaryExtractor:
    """Explicit boundary handler between AST and domain."""
    
    @staticmethod
    def safe_extract(node: ast.AST, attr: str, default: Any = None) -> Any:
        """Boundary method: Safe attribute extraction."""
        return getattr(node, attr, default)
    
    @staticmethod
    def extract_identifier(node: ast.AST) -> str:
        """Boundary method: Extract semantic name from various node types."""
        # Single place for AST polymorphism
        extractors = {
            ast.Name: lambda n: n.id,
            ast.Attribute: lambda n: n.attr,
            ast.FunctionDef: lambda n: n.name
        }
        extractor = extractors.get(type(node), lambda n: "unknown")
        
        try:
            return str(extractor(node))
        except Exception:
            return "unknown"
```
