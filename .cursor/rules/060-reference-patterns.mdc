---
description: SDA transformation patterns and examples
globs:
alwaysApply: false
---

# SDA Reference Patterns

## Constructive Type Transformation (The Heart of SDA)
```python
# ❌ Before: Assertive type coercion
def process_data(raw: dict) -> DomainModel:
    return cast(DomainModel, raw)  # "Trust me"
    
def handle_response(data: Any) -> ProcessedData:
    return ProcessedData(**data)  # type: ignore  # Suppressing instead of solving

# ✅ After: Constructive type transformation
def process_data(raw: dict) -> DomainModel:
    # Step 1: Unpack components explicitly
    user_id_raw = raw.get("user_id")
    amount_raw = raw.get("amount")
    status_raw = raw.get("status")
    
    # Step 2: Transform each component to domain type
    user_id = UserId(value=user_id_raw) if user_id_raw else UserId.anonymous()
    amount = Amount.from_raw(amount_raw) if amount_raw else Amount.zero()
    status = TransactionStatus(status_raw) if status_raw else TransactionStatus.PENDING
    
    # Step 3: Construct target from typed components
    return DomainModel(
        user_id=user_id,
        amount=amount,
        status=status
    )
    # Construction IS the proof of type safety
```

## Conditional → Type Dispatch
```python
# ❌ Before: Procedural conditional chains
violation_processor = get_violation_processor(violation_type)

# ✅ After: Type dispatch with enum behavior
class ViolationType(StrEnum):
    isinstance_violations = "isinstance_violations"
    hasattr_violations = "hasattr_violations"

    def create_finding(self, node: CodeNode) -> Finding:
        # Enum knows how to create its own findings
        return Finding(type=self, node=node)
```

## Runtime Checking → Discriminated Unions
```python
# ❌ Before: Runtime type checking with procedural logic
order_processor = get_order_processor(order.status)

# ✅ After: Discriminated union with type dispatch
class OrderStatus(StrEnum):
    PAID = "paid"
    DRAFT = "draft"
    
    def process(self, order: "Order") -> ProcessResult:
        # Type-safe dispatch without generics
        return {
            OrderStatus.PAID: order.ship,
            OrderStatus.DRAFT: order.reject_shipping
        }[self](order)
```

## Primitive → Value Object
```python
# ❌ Before: Primitive obsession
file_path: str = "src/models.py"
# Conditional logic with primitives

# ✅ After: Value object with domain intelligence
class FilePath(BaseModel):
    path: str

    @computed_field
    @property
    def file_type(self) -> FileType:
        # Push string operations to type system
        return FileType.from_path(self.path)

    @computed_field
    @property
    def module_name(self) -> ModuleName:
        # Domain intelligence in value objects
        return ModuleName.from_path(self.path)
```

## State → Discriminated Union Pattern
```python
# ❌ Before: Procedural state logic
state_processor = get_state_processor(current_state)

# ✅ After: Discriminated union state dispatch
class ProcessingState(StrEnum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    
    def get_result(self, value: ProcessValue, default: ProcessValue) -> ProcessValue:
        # Pure type dispatch without lambdas
        return {
            ProcessingState.ACTIVE: value,
            ProcessingState.INACTIVE: default
        }[self]
```

## External System → Domain Intelligence
```python
# ❌ Before: Fighting external polymorphism with conditionals
if isinstance(node, ast.If):
    return ConditionalViolation(node)
elif isinstance(node, ast.For):
    return LoopViolation(node)
# Nested conditionals throughout analysis

# ✅ After: Single boundary extraction + pure domain logic
def extract_analysis_domain(node: ast.AST) -> AnalysisDomain | None:
    """Pure boundary crossing: AST → Domain meaning."""
    metadata = extract_ast_metadata(node)
    
    # Single place for external type dispatch
    extractors = {
        ast.If: lambda n: ConditionalDomain.from_ast(n, metadata),
        ast.For: lambda n: LoopDomain.from_ast(n, metadata),
        ast.FunctionDef: lambda n: FunctionDomain.from_ast(n, metadata)
    }
    
    extractor = extractors.get(type(node))
    return extractor(node) if extractor else None

class ConditionalDomain(BaseModel):
    """Domain intelligence extracted from external AST."""
    test_expression: str
    metadata: ASTNodeMetadata
    
    @classmethod
    def from_ast(cls, node: ast.If, metadata: ASTNodeMetadata) -> 'ConditionalDomain':
        # Boundary method: Extract semantics once
        return cls(
            test_expression=extract_test_semantics(node.test),
            metadata=metadata
        )
    
    @computed_field
    @property
    def violation_type(self) -> ViolationType:
        # Pure domain logic with no external dependencies
        return self.metadata.category.get_violation_type()
```

## Boundary Services → Pure Functions
```python
# ❌ Before: Service classes with stateful boundary handling
class ASTAnalyzer:
    def __init__(self):
        self.violations = []  # Stateful accumulation
    
    def analyze_file(self, path):
        # Mixed boundary + domain logic
        tree = ast.parse(path.read_text())
        self._visit_node(tree)  # Stateful recursion
        return self.violations

# ✅ After: Pure functional boundary crossing
def analyze_ast_file(file_path: Path) -> list[Finding]:
    """Pure function: File → Domain findings."""
    tree = ast.parse(file_path.read_text())  # Boundary operation
    return analyze_ast_tree(tree)  # Pure domain logic

def analyze_ast_tree(tree: ast.AST) -> list[Finding]:
    """Pure function: External structure → Domain findings."""
    domains = extract_all_domains(tree)
    return [domain.analyze() for domain in domains if domain]

class DomainExtractor:
    """Functional visitor that produces domain models."""
    
    def visit(self, node: ast.AST) -> list[AnalysisDomain]:
        current = extract_analysis_domain(node)  # Boundary crossing
        children = [
            child_domain 
            for child in ast.iter_child_nodes(node)
            for child_domain in self.visit(child)
        ]
        return ([current] if current else []) + children
```

## TypeAdapter for Boundary Validation
```python
# ❌ Before: Manual validation at boundaries
def process_request(raw_data: dict):
    if 'user_id' not in raw_data:
        raise ValueError("Missing user_id")
    if not isinstance(raw_data['amount'], (int, float)):
        raise ValueError("Invalid amount")
    # Manual validation hell

# ✅ After: TypeAdapter for boundary safety
from pydantic import TypeAdapter

# Boundary validation adapters
HTTP_REQUEST_ADAPTER = TypeAdapter(HttpRequestData)
AST_NODE_ADAPTER = TypeAdapter(ast.AST)

def process_request(raw_data: dict) -> ProcessResult:
    """Safe boundary crossing with validation."""
    validated_request = HTTP_REQUEST_ADAPTER.validate_python(raw_data)
    domain_command = extract_command_from_request(validated_request)
    return domain_command.execute()

class ASTBoundaryExtractor:
    """Explicit boundary handler using discriminated unions."""
    
    @staticmethod
    def extract_node_type(node: ast.AST) -> NodeType:
        """Convert external type to domain enum."""
        type_mapping = {
            ast.Name: NodeType.NAME,
            ast.Attribute: NodeType.ATTRIBUTE,
            ast.FunctionDef: NodeType.FUNCTION,
            ast.If: NodeType.CONDITIONAL,
            ast.For: NodeType.LOOP
        }
        return type_mapping.get(type(node), NodeType.UNKNOWN)
    
    @staticmethod
    def extract_identifier(node: ast.AST) -> str:
        """Extract semantic name using type dispatch."""
        # Direct attribute access in extractors, no getattr
        extractors = {
            ast.Name: lambda n: n.id,
            ast.Attribute: lambda n: n.attr,
            ast.FunctionDef: lambda n: n.name
        }
        extractor = extractors.get(type(node))
        return extractor(node) if extractor else "unknown"
```

## Constructive Transformation at Boundaries
```python
# ❌ Before: Weakening types to satisfy type checker
class ItemProcessor:
    def process(self, item: object) -> ProcessResult:
        # Weakened type requires runtime checks
        if not isinstance(item, SpecificItem):
            raise TypeError("Expected SpecificItem")
        return self._process_specific(item)

# ✅ After: Strong typing with constructive transformation
class ItemProcessor:
    def process(self, item: SpecificItem) -> ProcessResult:
        # Strong type, no runtime checks needed
        domain_item = DomainItem.from_specific(item)
        return domain_item.process()

# ✅ After: When dealing with external polymorphism
def extract_domain_meaning(external_obj: ExternalType) -> DomainModel:
    """Single boundary crossing with constructive transformation."""
    # Step 1: Extract type discriminator
    obj_type = extract_type_indicator(external_obj)
    
    # Step 2: Type-specific extraction with unpacking
    if obj_type == ObjectType.TYPE_A:
        # Unpack specific fields
        field_1 = external_obj.specific_field_1
        field_2 = external_obj.specific_field_2
        
        # Construct domain model
        return TypeADomain(
            value_1=DomainValue.from_raw(field_1),
            value_2=DomainValue.from_raw(field_2)
        )
    elif obj_type == ObjectType.TYPE_B:
        # Different unpacking for different type
        data_field = external_obj.data_field
        config_field = external_obj.config_field
        
        return TypeBDomain(
            data=DomainData.from_raw(data_field),
            config=DomainConfig.from_raw(config_field)
        )
```
