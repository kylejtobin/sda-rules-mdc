---
description: SDA transformation patterns and examples
globs:
alwaysApply: false
---

# SDA Reference Patterns

## Conditional → Type Dispatch
```python
# ❌ Before: Procedural conditional chains
result_handler = get_result_handler(result_type)

# ✅ After: Type dispatch with enum behavior
class ValidationResult(StrEnum):
    TYPE_MISMATCH = "type_mismatch"
    MISSING_FIELD = "missing_field"
    INVALID_VALUE = "invalid_value"

    def create_report(self, context: ValidationContext) -> Report:
        # Enum knows how to create its own reports
        return Report(type=self, context=context)
```

## Runtime Checking → Discriminated Unions
```python
# ❌ Before: Runtime type checking with procedural logic
order_processor = get_order_processor(order.status)

# ✅ After: Discriminated union with type dispatch
class OrderStatus(StrEnum):
    PAID = "paid"
    DRAFT = "draft"
    
    def process(self, order: "Order") -> ProcessResult:
        # Type-safe dispatch without generics
        return {
            OrderStatus.PAID: order.ship,
            OrderStatus.DRAFT: order.reject_shipping
        }[self](order)
```

## Primitive → Value Object
```python
# ❌ Before: Primitive obsession
file_path: str = "src/models.py"
# Conditional logic with primitives

# ✅ After: Value object with domain intelligence
class FilePath(BaseModel):
    path: str

    @computed_field
    @property
    def file_type(self) -> FileType:
        # Push string operations to type system
        return FileType.from_path(self.path)

    @computed_field
    @property
    def module_name(self) -> ModuleName:
        # Domain intelligence in value objects
        return ModuleName.from_path(self.path)
```

## State → Discriminated Union Pattern
```python
# ❌ Before: Procedural state logic
state_processor = get_state_processor(current_state)

# ✅ After: Discriminated union state dispatch
class ProcessingState(StrEnum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    
    def get_result(self, value: ProcessValue, default: ProcessValue) -> ProcessValue:
        # Pure type dispatch without lambdas
        return {
            ProcessingState.ACTIVE: value,
            ProcessingState.INACTIVE: default
        }[self]
```

## External System → Domain Intelligence
```python
# ❌ Before: Fighting external polymorphism with conditionals
if external_event.get("type") == "user_action":
    return UserActionEvent(external_event)
elif external_event.get("type") == "system_alert":
    return SystemAlertEvent(external_event)
# Nested conditionals throughout processing

# ✅ After: Single boundary extraction + pure domain logic
def extract_domain_event(external_data: dict) -> DomainEvent | None:
    """Pure boundary crossing: External → Domain meaning."""
    event_type = external_data.get("type")
    metadata = extract_event_metadata(external_data)
    
    # Single place for external type dispatch
    extractors = {
        "user_action": lambda d: UserAction.from_external(d, metadata),
        "system_alert": lambda d: SystemAlert.from_external(d, metadata),
        "scheduled_task": lambda d: ScheduledTask.from_external(d, metadata)
    }
    
    extractor = extractors.get(event_type)
    return extractor(external_data) if extractor else None

class UserAction(BaseModel):
    """Domain intelligence extracted from external event."""
    action_type: ActionType
    metadata: EventMetadata
    
    @classmethod
    def from_external(cls, data: dict, metadata: EventMetadata) -> 'UserAction':
        # Boundary method: Extract semantics once
        return cls(
            action_type=ActionType(data.get("action", "unknown")),
            metadata=metadata
        )
    
    @computed_field
    @property
    def requires_audit(self) -> bool:
        # Pure domain logic with no external dependencies
        return self.action_type.is_sensitive()
```

## Boundary Services → Pure Functions
```python
# ❌ Before: Service classes with stateful boundary handling
class DocumentProcessor:
    def __init__(self):
        self.results = []  # Stateful accumulation
    
    def process_file(self, path):
        # Mixed boundary + domain logic
        raw_content = path.read_text()
        self._parse_sections(raw_content)  # Stateful recursion
        return self.results

# ✅ After: Pure functional boundary crossing
def process_document_file(file_path: Path) -> list[ProcessedSection]:
    """Pure function: File → Domain results."""
    raw_content = file_path.read_text()  # Boundary operation
    return process_document_content(raw_content)  # Pure domain logic

def process_document_content(content: str) -> list[ProcessedSection]:
    """Pure function: External content → Domain sections."""
    sections = extract_all_sections(content)
    return [section.process() for section in sections if section]

class SectionExtractor:
    """Functional extractor that produces domain models."""
    
    def extract(self, raw_section: dict) -> list[DomainSection]:
        current = extract_domain_section(raw_section)  # Boundary crossing
        children = [
            child_section 
            for child in raw_section.get("subsections", [])
            for child_section in self.extract(child)
        ]
        return ([current] if current else []) + children
```

## TypeAdapter for Boundary Validation
```python
# ❌ Before: Manual validation at boundaries
def process_request(raw_data: dict):
    if 'user_id' not in raw_data:
        raise ValueError("Missing user_id")
    if not isinstance(raw_data['amount'], (int, float)):
        raise ValueError("Invalid amount")
    # Manual validation hell

# ✅ After: TypeAdapter for boundary safety
from pydantic import TypeAdapter

# Boundary validation adapters
HTTP_REQUEST_ADAPTER = TypeAdapter(HttpRequestData)
EXTERNAL_EVENT_ADAPTER = TypeAdapter(ExternalEventData)

def process_request(raw_data: dict) -> ProcessResult:
    """Safe boundary crossing with validation."""
    validated_request = HTTP_REQUEST_ADAPTER.validate_python(raw_data)
    domain_command = extract_command_from_request(validated_request)
    return domain_command.execute()

class ExternalDataExtractor:
    """Explicit boundary handler using discriminated unions."""
    
    @staticmethod
    def extract_entity_type(external_obj: dict) -> EntityType:
        """Convert external type to domain enum."""
        type_value = external_obj.get("entity_type", "")
        type_mapping = {
            "customer": EntityType.CUSTOMER,
            "product": EntityType.PRODUCT,
            "order": EntityType.ORDER,
            "invoice": EntityType.INVOICE,
            "payment": EntityType.PAYMENT
        }
        return type_mapping.get(type_value, EntityType.UNKNOWN)
    
    @staticmethod
    def extract_identifier(external_obj: dict) -> str:
        """Extract semantic identifier using type dispatch."""
        entity_type = external_obj.get("entity_type", "")
        # Direct field access in extractors, no dynamic lookups
        extractors = {
            "customer": lambda obj: obj.get("customer_id", ""),
            "product": lambda obj: obj.get("sku", ""),
            "order": lambda obj: obj.get("order_number", "")
        }
        extractor = extractors.get(entity_type)
        return extractor(external_obj) if extractor else "unknown"
```

## Constructive Transformation at Boundaries
```python
# ❌ Before: Weakening types to satisfy type checker
class ItemProcessor:
    def process(self, item: object) -> ProcessResult:
        # Weakened type requires runtime checks
        if not isinstance(item, SpecificItem):
            raise TypeError("Expected SpecificItem")
        return self._process_specific(item)

# ✅ After: Strong typing with constructive transformation
class ItemProcessor:
    def process(self, item: SpecificItem) -> ProcessResult:
        # Strong type, no runtime checks needed
        domain_item = DomainItem.from_specific(item)
        return domain_item.process()

# ✅ After: When dealing with external polymorphism
def extract_domain_meaning(external_obj: ExternalType) -> DomainModel:
    """Single boundary crossing with constructive transformation."""
    # Step 1: Extract type discriminator
    obj_type = extract_type_indicator(external_obj)
    
    # Step 2: Type-specific extraction with unpacking
    if obj_type == ObjectType.TYPE_A:
        # Unpack specific fields
        field_1 = external_obj.specific_field_1
        field_2 = external_obj.specific_field_2
        
        # Construct domain model
        return TypeADomain(
            value_1=DomainValue.from_raw(field_1),
            value_2=DomainValue.from_raw(field_2)
        )
    elif obj_type == ObjectType.TYPE_B:
        # Different unpacking for different type
        data_field = external_obj.data_field
        config_field = external_obj.config_field
        
        return TypeBDomain(
            data=DomainData.from_raw(data_field),
            config=DomainConfig.from_raw(config_field)
        )
```
