---
description: Patterns for handling external system boundaries
globs: ["**/*.py"]
alwaysApply: true
---

# Boundary Intelligence Patterns

## Core Principle
Don't fight external systems—extract domain intelligence from them at the boundary.

## Boundary Recognition
- **External systems**: APIs, databases, file systems, parse trees, config files
- **Domain models**: Your semantic understanding of external data (MUST be Pydantic BaseModel)
- **Extraction layer**: Pure functions that cross boundaries once
- **TypeAdapter**: MANDATORY tool for all boundary validation - no raw dict processing allowed

## Constructive Boundary Transformation
MANDATORY: All external data MUST pass through TypeAdapter validation before domain construction.

- **Step 1**: MANDATORY TypeAdapter validation
- **Step 2**: Unpack validated structure  
- **Step 3**: Transform to BaseModel domain types
- **Step 4**: Construct BaseModel (construction IS validation)

## Single Extraction Point Pattern
- **REQUIRED**: One extraction function per external system type
- **REQUIRED**: StrEnum types MUST have extraction methods
- **REQUIRED**: Use dictionary dispatch for extraction logic
- **BANNED**: Multiple extraction points for same external type

## TypeAdapter for Boundary Validation
ABSOLUTE REQUIREMENT: Every external data crossing MUST use TypeAdapter.validate_python() - no exceptions.

```python
# MANDATORY: Use this exact syntax for boundary validation
ADAPTER = TypeAdapter(ExternalDataType)
validated_data = ADAPTER.validate_python(raw_external_data)
```
- **MANDATORY**: Define TypeAdapter for every external data type
- **MANDATORY**: Use `validate_python()` method for all validation
- **REQUIRED**: Validate before any domain processing

## Pure Functional Extraction
- **REQUIRED**: All extraction functions MUST be stateless
- **REQUIRED**: Use `@staticmethod` for extraction methods
- **REQUIRED**: Separate I/O operations from domain processing
- **BANNED**: Stateful extraction that accumulates data

## Boundary Service Pattern
- **REQUIRED**: Immediate domain conversion at boundary
- **REQUIRED**: Use `@classmethod` constructors for external data transformation
- **REQUIRED**: All boundary services MUST return BaseModel types
- **BANNED**: Returning raw external data from boundary services

## Metadata Extraction Pattern
- **REQUIRED**: Extract metadata without coupling to external structure
- **REQUIRED**: Use pure functions for metadata extraction
- **REQUIRED**: Construct domain events with extracted metadata
- **BANNED**: Direct coupling to external object structure

## Boundary Rules

### Required Patterns
- **Single extraction point** - One place per external system type
- **TypeAdapter validation** - MANDATORY for all external data
- **BaseModel domain types** - All domain models MUST inherit from BaseModel
- **Immediate conversion** - External → BaseModel at boundary
- **Pure extraction** - No side effects in transformation

### Banned Patterns
- **Raw dict processing** - BANNED. Use TypeAdapter.validate_python()
- **Leaky abstractions** - Domain wrapping external objects
- **Mixed logic** - Boundary + domain in same function
- **Stateful extraction** - Accumulating during crossing
- **Late conversion** - External data deep in domain
- **Non-BaseModel domain types** - All domain models MUST be BaseModel

## Type System Boundary Principle
When discriminated unions provide stronger guarantees than type checkers:
- **Keep domain models strongly typed** - Never weaken for external data
- **Use constructive transformation** - Unpack and explicitly type
- **Type ignore is LAST RESORT** - Only when construction impossible
- **Document domain guarantees** - Explain why type ignore is safe