---
description: Protocol-Service-Boundary pattern for module structure
globs: ["**/*.py"]
alwaysApply: true
---

# Protocol-Service-Boundary Pattern

## Core Principle
Every module follows a three-part structure that enforces dependency inversion and clean boundaries.

## The Three Parts

### 1. Protocol Definition (`protocols.py`)
- Declares the module's public contract
- Defines what capabilities the module provides
- Uses Python Protocol types for interface definition
- No implementation details, only method signatures

### 2. Service Implementation (`service.py`)
- Implements the protocol's contract
- Receives all dependencies through constructor injection
- Never creates its own dependencies
- Contains the actual logic and orchestration

### 3. Boundary Wiring (`__init__.py`)
- Provides creation functions that wire dependencies
- The ONLY place concrete implementations are imported
- Exports only protocols and creation functions
- Handles all dependency injection for the module

## Dependency Rules

### Modules MUST
- Import protocols from other modules, never concrete services
- Use constructor injection for all dependencies
- Export a minimal public API (protocol + creation function)
- Follow this three-part structure uniformly

### Modules MUST NOT
- Import concrete implementations from other modules
- Create their own dependencies internally
- Export service classes directly
- Mix wiring logic with business logic

## Usage Pattern
- Depending modules import `from module import ModuleProtocol, create_module`
- Orchestration layers wire everything using creation functions
- Tests inject mock implementations of protocols
- Runtime wiring happens at application boundaries

## Benefits
- Prevents circular imports through clear dependency direction
- Enables testing through protocol-based mocking
- Supports lazy loading of implementations
- Makes module contracts explicit
- Maintains clean architectural boundaries