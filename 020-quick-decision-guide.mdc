---
description: Quick decisions for semantic domain architecture
globs: ["**/*.py"]
alwaysApply: true
---

# Semantic Decision Guide

<modeling_decisions>
See primitive type? → Create value object with validation
See string choices? → Create Enum with behavior  
See business rule? → Add method to the model
See state change? → Use model_copy() to return new instance
See external need? → Define Protocol interface
</modeling_decisions>

<implementation_rules>
ALWAYS:
- model_config = {"frozen": True}
- Field() validators for constraints
- Computed fields for derived values
- Type every collection: list[T], dict[K, V]
- Return new instances from methods

NEVER:
- Naked primitives (str, int, float)
- Business logic in services
- Mutable models (unless explicit reason)
- getattr/setattr on models
- Optional[T] without documenting None meaning
</implementation_rules>

<quick_test>
Read your model. Can you answer:
1. What constraints exist?
2. What operations are valid?
3. What states are possible?

If unclear, add more model intelligence.
</quick_test>